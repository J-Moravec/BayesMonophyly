"""This script reads tree in newick format and posterior tree sample from
MrBayes or BEAST and outputs number (and ratio) of trees that have the same
topology."""

from __future__ import division
import sys
import re
import math
import argparse as arg
try:
    import ete2
except ImportError:
    raise ImportError("This script require ete2. Please, make sure it is installed.")

def parse_args():
    parser = arg.ArgumentParser(
        prog="PosteriorTopology",
        description=(
            "This script reads tree in newick format and posterior tree sample"
            " from MrBayes or BEAST and outputs number (and ratio) of trees"
            " that have the same topology. This can be used for implicit"
            " testing for topology with bayesian posterior tree sample."
            )
        )
    parser.add_argument(
        "-t", "--tree", required=True,
        help=(
            "Tree topology in newick format. Branch lenghts are ignored."
            )
        )
    parser.add_argument(
        "-p", "--posterior", required=True,
        help=(
            "MrBayes or BEAST posterior tree samples from bayesian tree"
            " analysis."
            )
        )
    args = parser.parse_args()
    return(args)


class ParsingError(Exception):
    """Unexpected string while parsing file."""
    pass


class TaxaError(Exception):
    """Different taxa or number of taxa in trees."""
    pass


def parse_posterior_sample(treefile):
    """Parse posterior tree sample file from BEAST or MrBayes.

    Parse posterior tree sample file generated by MrBayes or BEAST software.
    These files are of NEXUS format and contain several block. Of these blocks,
    only the Translate and Tree blocks are of interest. Translate block contain
    list of species in trees and their translation, as names are translated
    into numbers. Tree block contains posterior sample of trees.

    This parser will search this file and returns Translate block and trees.
    There are several checks employed to ensure, that parsing is correct.

    Parameters
    ----------
    treefile : string
        path to file that is to be parsed

    Returns
    -------
    translated_taxa : dictionary
        original names of species in file and their numeric translation
    """
    tree_file_text = []
    try:
        tree_file = open(treefile,"r")
    except IOError:
        raise ParsingError("ERROR: Couldn't open file, does file exists?")
    else:
        with tree_file:
            tree_file_text = tree_file.readlines()
    #Various checks:
    #first line must be #NEXUS
    if(tree_file_text[0].strip("\n\t ").lower() != "#nexus"):
        raise ParsingError("ERROR: No NEXUS header. Is file NEXUS?")

    #find begin trees
    begin_block_start = 0
    for num,line in enumerate(tree_file_text):
        if line.strip("\n\t ").lower() == "begin trees;":
            begin_block_start=num
            break
    if begin_block_start == 0:
        raise ParsingError("ERROR: Begin trees block not found!")

    #check if following one is translate:
    if tree_file_text[begin_block_start+1].strip("\n\t ").lower() != "translate":
        raise ParsingError(
                "ERROR: Misformed Begin trees block,"
                " \"translate\" not found."
                )

    #translate block, numbers from 1 to ntaxa
    #but because taxa block is not required 
    #number of taxa is not known and must be estimated from translate
    translated_taxa = dict()
    begin_block_end = 0
    for num,line in enumerate(tree_file_text[begin_block_start+2 : ]):
        pair = line.strip("\n\t, ").split()
        if len(pair) != 2:
            begin_block_end = num + begin_block_start + 2
            break
        else:
            translated_taxa[int(pair[0]) ] = pair[1]
    #check if begin_block_end has changed:
    if begin_block_end == 0:
        raise ParsingError("ERROR: end of translation block not found.")

    #now, every tree should start with "tree", so find a first tree, if not next:
    trees_start = 0
    for num,line in enumerate(tree_file_text[begin_block_end + 1 : ]):
        if line.strip("\n\t ")[0:4].lower() == "tree":
            trees_start = num + begin_block_end + 1
            break
    #test if trees_start changed:
    if trees_start == 0:
        raise ParsingError("ERROR: no tree was found!")
    trees = []
    #read all trees and put them into list
    for line in tree_file_text[trees_start:]:
        #get tree
        line=line.strip("\n\t ;")
        if line.lower() == "end":
            #end of tree block
            break
        tree=line.split(" = ")[1].strip()
        if(tree[0:5] == "[&U] "): #remove "[&U] ", if present
            tree = tree[5:]
        #delete [&something=number] tags from BEAST
        #TODO better matching is required
        #in my file, I am currently matching only [&rate=number]
        if "[" in tree:
            tree = re.sub("\[&\w+=[0-9]*\.?[0-9]*([eE]-[0-9]+)?\]", "", tree)
        #get cladogram
        tree = re.sub(":[0-9]+\.?[0-9]*([eE]-[0-9]+)?", "", tree)
        trees.append(tree)
    return(translated_taxa, trees)


def check_species_in_taxa(node_names,translated_taxa):
    """Check if specified species are in dictionary.

    Simple check if species required for monophyly are in species contained
    contained in tree.

    Parameters
    ----------
    species : list of strings
        list of species for monophyly
    translated_taxa : dictionary
        dictionary of species and their number from taxa block of nexus file

    Returns
    -------
    """
    #test if all species are in translated_taxa
    taxa_in_trees = translated_taxa.values()
    for node_name in node_names:
        if not node_name in taxa_in_trees:
            raise TaxaError("Species \"{0}\" is not in tree taxa!".format(node_name))


def invert_dict(dictionary):
    """Inverts dictionary (keys become values and values become keys) and turn
    keys and values into strings.""" 
    inverted_dict = {str(value):str(key) for key, value in dictionary.iteritems()}
    return(inverted_dict)


def parse_treefile(treefile):
    try:
        tree_file = open(treefile,"r")
    except IOError:
        raise ParsingError("ERROR: Couldn't open file, does file exists?")
    else:
        with tree_file:
            tree_text = tree_file.readlines()[0].rstrip("\n")
    tree_text = re.sub(":[0-9]+\.?[0-9]*([eE]-[0-9]+)?", "", tree_text)
    return(tree_text)


def get_node_names(tree_text):
    """Parse newick string and returns list of node names."""
    node_names = tree_text.replace("(","").replace(")","").rstrip(";")
    return(node_names.split(","))


def recode_tree(tree_text, reverted_dict):
    recoded_tree = reduce(
        lambda x, kv: x.replace(*kv), reverted_dict.iteritems(), tree_text
        )
    return(recoded_tree)


def count_trees(recoded_tree, posterior_trees):
    topology_count = 0
    tree = ete2.Tree(recoded_tree)
    for posterior_tree in posterior_trees:
        try:
            posterior = ete2.Tree(posterior_tree + ";")
        except ete2.parser.newick.NewickError:
            print posterior_tree
            raise RuntimeError("ERROR: Problem with turning text"
                               " into tree with ete2!")
        result = tree.compare(posterior)
        if(result["rf"] == 0):
            topology_count+=1
    return(topology_count)


if __name__ == "__main__":
    args = parse_args()
    tree_text = parse_treefile(args.tree)
    tree_node_labels = get_node_names(tree_text)

    (taxa_dict, posterior_trees) = parse_posterior_sample(args.posterior)
    #test dimension of taxa:
    if len(tree_node_labels) != len(taxa_dict):
        raise TaxaError("ERROR: Input tree and trees in posterior tree sample"
                        " have a different number of taxa!")
    #test if all taxa match:
    check_species_in_taxa(tree_node_labels, taxa_dict)

    inverted_dict = invert_dict(taxa_dict)
    recoded_tree = recode_tree(tree_text, inverted_dict)
    topology_count = count_trees(recoded_tree, posterior_trees)
    total_trees = len(posterior_trees)
    output = (
        "Trees total: {0}\n"
        "Trees with input topology: {1}\n"
        "Posterior probability: {2:.4g}\n").format(total_trees, topology_count,
                             topology_count/total_trees)
    print(output)
